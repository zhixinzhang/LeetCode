package Company.LinkedIn;

import java.util.*;


/**
 * @author Luke(New Man) Zhang
 * @Date 5/15/2022 12:40 AM
 * <p>
 * Source Link: https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/
 * <p> https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/submissions/
 * Description:
 * <p> I can put the index pair for the two arrays in a priority queue and compute the answer gradually. However, the K can be up to 10^9. This will lead to TLE.
 * The element can be negative. Maybe I need to know the number of negative elements and handle 4 different combinations: (negative array 1, negative array 2), (negative array 1, positive array 2), (positive array 1, negative array 2), (positive array 1, positive array 2). At least, I can know the number of products of each combination and locate k-th product among them.
 * Even though I know which combination the k-th product belongs to, it doesn't guarantee I can use the priority queue approach. I need another hint.
 * Continue with above, I think I need some way to eliminate some number of products step by step to reach the goal.
 * Since the array is sorted, if I turn my attention on nums1[i] x nums2[j], I can know there are j + 1 products which are less than or equal to nums1[i] x nums2[j] that are generated by nums1[i]. Then I realize that I should try the binary search.
 * Algorithm
 *
 * Binary search the answer
 * For each nums1[i], count the number of products that are less than or equal to the current guess
 * <p>
 * Time and Space Complexity:
 * <p> Java Double Binary Search O(log10^10 x MlogN)
 * <p>
 * Data structure
 */

public class _2040_KthSmallestProductofTwoSortedArrays_BinarySearch {
    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {
        long lo = (long) -1e10;
        long hi = (long) 1e10;
        while (lo < hi) {
            final long mid = lo + hi + 1 >> 1;
            if (f(nums1, nums2, mid) < k) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
        return lo;
    }

    private static long f(int[] nums1, int[] nums2, long mid) {
        long count = 0;
        for (int num : nums1) {
            int lo = 0;
            int hi = nums2.length;
            if (num < 0) {
                while (lo < hi) {
                    final int m = lo + hi >>> 1;
                    if ((long) nums2[m] * num >= mid) {
                        lo = m + 1;
                    } else {
                        hi = m;
                    }
                }
                count += nums2.length - lo;
            } else {
                while (lo < hi) {
                    final int m = lo + hi >>> 1;
                    if ((long) nums2[m] * num < mid) {
                        lo = m + 1;
                    } else {
                        hi = m;
                    }
                }
                count += lo;
            }
        }
        return count;
    }
}


